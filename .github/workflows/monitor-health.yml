name: Journal Health Monitor

on:
  schedule:
    - cron: '0 */6 * * *'  # Every 6 hours
  workflow_dispatch:

permissions:
  contents: write
  issues: write

jobs:
  monitor:
    name: Health Check
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check recent workflow runs
        id: workflows
        uses: actions/github-script@v7
        with:
          script: |
            // Get recent workflow runs for process-submission
            const { data: runs } = await github.rest.actions.listWorkflowRuns({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'process-submission.yml',
              per_page: 20
            });

            const recentRuns = runs.workflow_runs;
            const last24h = new Date(Date.now() - 24 * 60 * 60 * 1000);

            const recent = recentRuns.filter(r => new Date(r.created_at) > last24h);
            const successful = recent.filter(r => r.conclusion === 'success').length;
            const failed = recent.filter(r => r.conclusion === 'failure').length;
            const total = recent.length;

            const successRate = total > 0 ? Math.round((successful / total) * 100) : 100;

            core.setOutput('total_runs', total);
            core.setOutput('successful_runs', successful);
            core.setOutput('failed_runs', failed);
            core.setOutput('success_rate', successRate);

            // Calculate average processing time
            let avgTime = 0;
            if (successful > 0) {
              const successfulRuns = recent.filter(r => r.conclusion === 'success');
              const times = successfulRuns.map(r => {
                const start = new Date(r.created_at);
                const end = new Date(r.updated_at);
                return (end - start) / 1000 / 60; // minutes
              });
              avgTime = Math.round(times.reduce((a, b) => a + b, 0) / times.length);
            }
            core.setOutput('avg_processing_time', avgTime);

      - name: Check submission queue
        id: queue
        uses: actions/github-script@v7
        with:
          script: |
            // Get open issues with submission label
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'submission',
              state: 'open',
              per_page: 100
            });

            const pending = issues.filter(i =>
              i.labels.some(l => l.name === 'waiting-for-pdf' || l.name === 'processing')
            ).length;

            const total = issues.length;

            core.setOutput('pending_submissions', pending);
            core.setOutput('open_submissions', total);

            // Alert if too many pending
            if (pending > 10) {
              core.setOutput('queue_alert', 'high');
            } else {
              core.setOutput('queue_alert', 'normal');
            }

      - name: Check completed reviews
        id: reviews
        uses: actions/github-script@v7
        with:
          script: |
            // Count review files
            try {
              const { data: reviews } = await github.rest.repos.getContent({
                owner: context.repo.owner,
                repo: context.repo.repo,
                path: 'reviews'
              });

              const reviewDirs = reviews.filter(r => r.type === 'dir');
              core.setOutput('total_reviews', reviewDirs.length);
            } catch (e) {
              core.setOutput('total_reviews', 0);
            }

      - name: Create alert if needed
        if: steps.workflows.outputs.success_rate < 80 || steps.queue.outputs.queue_alert == 'high'
        uses: actions/github-script@v7
        with:
          script: |
            const successRate = parseInt('${{ steps.workflows.outputs.success_rate }}');
            const queueAlert = '${{ steps.queue.outputs.queue_alert }}';
            const pendingCount = '${{ steps.queue.outputs.pending_submissions }}';
            const failedCount = '${{ steps.workflows.outputs.failed_runs }}';

            let severity = 'warning';
            let title = '';
            let body = '';

            if (successRate < 50) {
              severity = 'critical';
              title = 'ðŸš¨ CRITICAL: Review Pipeline Failure Rate High';
              body = `## Critical Alert\n\nThe review pipeline is experiencing high failure rates.\n\n### Metrics\n- Success Rate: ${successRate}%\n- Failed Runs (24h): ${failedCount}\n- Pending Submissions: ${pendingCount}\n\n### Action Required\n- Check workflow logs for errors\n- Verify API keys are valid\n- Check for infrastructure issues`;
            } else if (successRate < 80) {
              severity = 'warning';
              title = 'âš ï¸ WARNING: Review Pipeline Issues Detected';
              body = `## Warning Alert\n\nThe review pipeline success rate has dropped.\n\n### Metrics\n- Success Rate: ${successRate}%\n- Failed Runs (24h): ${failedCount}\n\n### Possible Causes\n- Transient API errors\n- Invalid submission formats\n- Rate limiting`;
            } else if (queueAlert === 'high') {
              severity = 'warning';
              title = 'âš ï¸ WARNING: Submission Queue Building Up';
              body = `## Warning Alert\n\nThere are ${pendingCount} pending submissions in the queue.\n\n### Action Required\n- Check for stuck submissions\n- Verify workflow is running\n- Consider manual processing`;
            }

            if (title) {
              // Check for existing alert
              const { data: issues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                labels: 'alert,journal-health',
                state: 'open'
              });

              if (issues.length === 0) {
                await github.rest.issues.create({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  title: title,
                  body: body + `\n\n---\n*Auto-generated by Journal Health Monitor at ${new Date().toISOString()}*`,
                  labels: ['alert', 'journal-health', severity]
                });
              }
            }

      - name: Generate status report
        run: |
          mkdir -p output/status
          cat > output/status/journal-health.json << EOF
          {
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "workflow_success_rate": ${{ steps.workflows.outputs.success_rate }},
            "total_runs_24h": ${{ steps.workflows.outputs.total_runs }},
            "successful_runs": ${{ steps.workflows.outputs.successful_runs }},
            "failed_runs": ${{ steps.workflows.outputs.failed_runs }},
            "avg_processing_time_min": ${{ steps.workflows.outputs.avg_processing_time }},
            "pending_submissions": ${{ steps.queue.outputs.pending_submissions }},
            "open_submissions": ${{ steps.queue.outputs.open_submissions }},
            "total_reviews": ${{ steps.reviews.outputs.total_reviews }},
            "status": "$([ ${{ steps.workflows.outputs.success_rate }} -ge 80 ] && echo 'healthy' || ([ ${{ steps.workflows.outputs.success_rate }} -ge 50 ] && echo 'degraded' || echo 'critical'))"
          }
          EOF

      - name: Commit status
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ðŸ“Š Update journal health status"
          file_pattern: "output/status/**"
