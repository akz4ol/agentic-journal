name: Process Submission

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: write

env:
  PYTHON_VERSION: '3.11'
  PDF_WORKER_URL: 'https://agentic-journal-pdf.blog-mot2gmob.workers.dev'

jobs:
  # Process submission when issue is created with PDF attached
  process-submission:
    name: Process Submission
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened' && contains(github.event.issue.labels.*.name, 'submission')) ||
      (github.event_name == 'issue_comment' && contains(github.event.issue.labels.*.name, 'submission'))
    runs-on: ubuntu-latest
    steps:
      - name: Check for PDF (R2 or GitHub attachment)
        id: check-pdf
        uses: actions/github-script@v7
        with:
          script: |
            // Check both issue body and comment for PDF
            const issueBody = context.payload.issue.body || '';
            const commentBody = context.eventName === 'issue_comment' ? (context.payload.comment.body || '') : '';

            console.log('Event type:', context.eventName);
            console.log('Checking for PDF source...');

            // Check for R2 storage URL (direct upload)
            const r2Pattern = /\*\*Storage:\*\* R2\s*\n\*\*URL:\*\* (https:\/\/agentic-journal-pdf[^\s]+)/;
            const r2Match = issueBody.match(r2Pattern);

            if (r2Match) {
              core.setOutput('has_pdf', 'true');
              core.setOutput('pdf_url', r2Match[1]);
              core.setOutput('pdf_source', 'r2');
              console.log('Found R2 PDF URL:', r2Match[1]);
              return;
            }

            // Check for direct-upload label (PDF is in R2)
            if (context.payload.issue.labels.some(l => l.name === 'direct-upload')) {
              // Extract submission ID and construct R2 URL
              const idMatch = issueBody.match(/\*\*Submission ID:\*\* ([\w-]+)/);
              if (idMatch) {
                const r2Url = `${process.env.PDF_WORKER_URL}/pdf/${idMatch[1]}`;
                core.setOutput('has_pdf', 'true');
                core.setOutput('pdf_url', r2Url);
                core.setOutput('pdf_source', 'r2');
                console.log('Constructed R2 PDF URL:', r2Url);
                return;
              }
            }

            // Look for GitHub attachment - various formats
            const patterns = [
              /\[([^\]]*\.pdf)\]\((https:\/\/github\.com\/user-attachments\/[^)]+)\)/gi,
              /\[([^\]]*)\]\((https:\/\/github\.com\/user-attachments\/[^)]+\.pdf[^)]*)\)/gi,
              /(https:\/\/github\.com\/user-attachments\/files\/[a-f0-9\/\-\.]+)/gi,
              /(https:\/\/github\.com\/user-attachments\/assets\/[a-f0-9-]+)/gi
            ];

            function findPdfUrl(content) {
              for (const pattern of patterns) {
                pattern.lastIndex = 0;
                const match = content.match(pattern);
                if (match) {
                  const urlMatch = match[0].match(/(https:\/\/github\.com\/user-attachments\/[^\s\)]+)/);
                  if (urlMatch) return urlMatch[1];
                }
              }
              return null;
            }

            // Check comment first, then issue body
            let pdfUrl = findPdfUrl(commentBody) || findPdfUrl(issueBody);

            if (pdfUrl) {
              core.setOutput('has_pdf', 'true');
              core.setOutput('pdf_url', pdfUrl);
              core.setOutput('pdf_source', 'github');
              console.log('Found GitHub PDF URL:', pdfUrl);
            } else {
              core.setOutput('has_pdf', 'false');
              console.log('No PDF found');

              // If this is a new issue without PDF, post instructions
              if (context.eventName === 'issues') {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `## ðŸ“„ Submission Received!\n\nâš ï¸ **No PDF detected in your submission.**\n\nPlease reply to this issue with your paper PDF attached (drag & drop the file into the comment box).\n\nOnce you attach the PDF, the automated review will begin.`
                });

                await github.rest.issues.addLabels({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  labels: ['waiting-for-pdf']
                });
              }
            }

      - name: Checkout
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: actions/checkout@v4

      - name: Setup Python
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        if: steps.check-pdf.outputs.has_pdf == 'true'
        run: pip install -r requirements.txt

      - name: Extract submission metadata
        if: steps.check-pdf.outputs.has_pdf == 'true'
        id: metadata
        uses: actions/github-script@v7
        with:
          script: |
            // Get the issue body
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const body = issue.data.body;

            // Extract submission ID
            const idMatch = body.match(/\*\*Submission ID:\*\* ([\w-]+)/);
            const submissionId = idMatch ? idMatch[1] : `AJ-${Date.now().toString(36).toUpperCase()}`;

            // Extract title
            const titleMatch = body.match(/\*\*Title:\*\* (.+)/);
            const title = titleMatch ? titleMatch[1].trim() : issue.data.title.replace('[Submission] ', '');

            core.setOutput('submission_id', submissionId);
            core.setOutput('title', title);
            console.log('Submission ID:', submissionId);
            console.log('Title:', title);

      - name: Download PDF
        if: steps.check-pdf.outputs.has_pdf == 'true'
        run: |
          mkdir -p submissions/${{ steps.metadata.outputs.submission_id }}

          PDF_SOURCE="${{ steps.check-pdf.outputs.pdf_source }}"
          PDF_URL="${{ steps.check-pdf.outputs.pdf_url }}"

          if [ "$PDF_SOURCE" = "r2" ]; then
            # R2 requires authentication header
            echo "Downloading from R2 storage..."
            curl -L -H "Authorization: Bearer ${{ secrets.PDF_WORKER_TOKEN }}" \
              "$PDF_URL" -o submissions/${{ steps.metadata.outputs.submission_id }}/paper.pdf
          else
            # GitHub attachment - direct download
            echo "Downloading from GitHub..."
            curl -L "$PDF_URL" -o submissions/${{ steps.metadata.outputs.submission_id }}/paper.pdf
          fi

          echo "PDF downloaded successfully"
          ls -la submissions/${{ steps.metadata.outputs.submission_id }}/

      - name: Create metadata.yaml
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const body = issue.data.body;
            const submissionId = '${{ steps.metadata.outputs.submission_id }}';

            // Parse metadata from issue body
            const titleMatch = body.match(/\*\*Title:\*\* (.+)/);
            const typeMatch = body.match(/\*\*Type:\*\* (\w+)/);
            const authorsMatch = body.match(/\*\*Authors:\*\* (.+)/);
            const abstractMatch = body.match(/### Abstract\n([\s\S]*?)(?=\n###|$)/);
            const keywordsMatch = body.match(/### Keywords\n(.+)/);

            const metadata = {
              title: titleMatch ? titleMatch[1].trim() : 'Untitled',
              paper_type: typeMatch ? typeMatch[1].toLowerCase() : 'research',
              authors: [],
              abstract: abstractMatch ? abstractMatch[1].trim() : '',
              keywords: keywordsMatch ? keywordsMatch[1].split(',').map(k => k.trim()) : []
            };

            // Parse authors
            if (authorsMatch) {
              const authorNames = authorsMatch[1].split(',').map(a => a.trim());
              metadata.authors = authorNames.map(name => ({ name, email: '', affiliation: '' }));
            }

            // Write metadata file as YAML (simple manual serialization)
            const authorsYaml = metadata.authors.map(a => `  - name: "${a.name}"\n    email: ""\n    affiliation: ""`).join('\n');
            const keywordsYaml = metadata.keywords.map(k => `  - "${k}"`).join('\n');
            const yamlContent = `title: "${metadata.title.replace(/"/g, '\\"')}"\npaper_type: ${metadata.paper_type}\nauthors:\n${authorsYaml}\nabstract: |\n  ${metadata.abstract.replace(/\n/g, '\n  ')}\nkeywords:\n${keywordsYaml}\n`;
            fs.writeFileSync(`submissions/${submissionId}/metadata.yaml`, yamlContent);
            console.log('Metadata created:', yamlContent);

      - name: Update issue status
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const submissionId = '${{ steps.metadata.outputs.submission_id }}';

            // Remove waiting-for-pdf, add processing
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'waiting-for-pdf'
              });
            } catch (e) {}

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['processing']
            });

            // Post status update
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## ðŸš€ Processing Started!\n\n**Submission ID:** ${submissionId}\n\nYour PDF has been received and the review process is starting.\n\n| Stage | Status |\n|-------|--------|\n| PDF Received | âœ… Complete |\n| Validation | ðŸ”„ In Progress |\n| Agent Reviews | â³ Pending |\n| Meta-Review | â³ Pending |\n\nWe'll update this issue with results as each stage completes.`
            });

      - name: Send submission received email
        if: steps.check-pdf.outputs.has_pdf == 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const submissionId = '${{ steps.metadata.outputs.submission_id }}';
            const title = '${{ steps.metadata.outputs.title }}';

            // Extract author email from issue body
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const body = issue.data.body || '';
            const authorsMatch = body.match(/\*\*Authors:\*\* (.+)/);

            // Try to send notification
            try {
              const response = await fetch('${{ env.PDF_WORKER_URL }}/notify/submission-received', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  submissionId,
                  title,
                  authorEmail: issue.data.user.email || '',
                  authorName: authorsMatch ? authorsMatch[1].split(',')[0].trim() : ''
                })
              });
              console.log('Email notification sent:', response.ok);
            } catch (e) {
              console.log('Email notification failed (non-critical):', e.message);
            }

      - name: Run validation
        if: steps.check-pdf.outputs.has_pdf == 'true'
        id: validate
        continue-on-error: true
        run: |
          python scripts/validate_submission.py
        env:
          SUBMISSION_ID: ${{ steps.metadata.outputs.submission_id }}

      - name: Run reviews
        if: steps.check-pdf.outputs.has_pdf == 'true' && steps.validate.outcome == 'success'
        run: |
          for agent in technical domain ethics clarity; do
            echo "Running $agent review..."
            python scripts/run_review.py --agent $agent || true
          done
        env:
          SUBMISSION_ID: ${{ steps.metadata.outputs.submission_id }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

      - name: Run meta-review
        if: steps.check-pdf.outputs.has_pdf == 'true' && steps.validate.outcome == 'success'
        id: meta
        run: python scripts/synthesize_reviews.py
        env:
          SUBMISSION_ID: ${{ steps.metadata.outputs.submission_id }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

      - name: Post review results
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const submissionId = '${{ steps.metadata.outputs.submission_id }}';

            let reviewComment = '';

            try {
              // Load meta-review (simple YAML parsing for key fields)
              const content = fs.readFileSync(`reviews/${submissionId}/meta-review.yaml`, 'utf8');

              // Extract key fields with regex
              const decisionMatch = content.match(/^decision:\s*(.+)$/m);
              const rationaleMatch = content.match(/^rationale:\s*[|>]?\s*\n([\s\S]*?)(?=^\w+:|$)/m);
              const weightedMatch = content.match(/weighted_average:\s*([\d.]+)/);
              const technicalMatch = content.match(/technical:\s*([\d.]+)/);
              const domainMatch = content.match(/domain:\s*([\d.]+)/);
              const ethicsMatch = content.match(/ethics:\s*([\d.]+)/);
              const clarityMatch = content.match(/clarity:\s*([\d.]+)/);

              const decision = decisionMatch ? decisionMatch[1].trim().toUpperCase() : 'PENDING';
              const rationale = rationaleMatch ? rationaleMatch[1].trim().replace(/^\s+/gm, '') : 'No rationale provided.';
              const weighted = weightedMatch ? parseFloat(weightedMatch[1]).toFixed(1) : 'N/A';
              const technical = technicalMatch ? parseFloat(technicalMatch[1]).toFixed(1) : 'N/A';
              const domain = domainMatch ? parseFloat(domainMatch[1]).toFixed(1) : 'N/A';
              const ethics = ethicsMatch ? parseFloat(ethicsMatch[1]).toFixed(1) : 'N/A';
              const clarity = clarityMatch ? parseFloat(clarityMatch[1]).toFixed(1) : 'N/A';

              const emoji = { 'ACCEPT': 'âœ…', 'MINOR_REVISION': 'ðŸ“', 'MAJOR_REVISION': 'ðŸ”„', 'REJECT': 'âŒ' }[decision] || 'â³';

              reviewComment = `## ${emoji} Review Complete: ${decision}\n\n**Submission ID:** ${submissionId}\n**Weighted Score:** ${weighted}/5.0\n\n### Score Breakdown\n\n| Agent | Score |\n|-------|-------|\n| Technical | ${technical} |\n| Domain | ${domain} |\n| Ethics | ${ethics} |\n| Clarity | ${clarity} |\n\n### Decision Rationale\n\n${rationale}\n\n---\n\n*Review generated by Agentic Journal's multi-agent peer review system.*\n\n[View on Dashboard](https://akz4ol.github.io/agentic-journal/dashboard/)`;

            } catch (error) {
              reviewComment = `## âš ï¸ Review Processing Issue\n\nThere was an issue processing the review. Please check the workflow logs.\n\nError: ${error.message}`;
            }

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: reviewComment
            });

            // Update labels
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'processing'
              });
            } catch (e) {}

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['completed']
            });

      - name: Send review complete email
        if: steps.check-pdf.outputs.has_pdf == 'true'
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const submissionId = '${{ steps.metadata.outputs.submission_id }}';
            const title = '${{ steps.metadata.outputs.title }}';

            try {
              // Load meta-review
              const content = fs.readFileSync(`reviews/${submissionId}/meta-review.yaml`, 'utf8');

              // Extract key fields
              const decisionMatch = content.match(/^decision:\s*(.+)$/m);
              const technicalMatch = content.match(/technical:\s*([\d.]+)/);
              const domainMatch = content.match(/domain:\s*([\d.]+)/);
              const ethicsMatch = content.match(/ethics:\s*([\d.]+)/);
              const clarityMatch = content.match(/clarity:\s*([\d.]+)/);
              const rationaleMatch = content.match(/^rationale:\s*[|>]?\s*\n([\s\S]*?)(?=^\w+:|$)/m);

              const decision = decisionMatch ? decisionMatch[1].trim() : 'Pending';
              const scores = {
                technical: technicalMatch ? parseFloat(technicalMatch[1]) : 0,
                domain: domainMatch ? parseFloat(domainMatch[1]) : 0,
                ethics: ethicsMatch ? parseFloat(ethicsMatch[1]) : 0,
                clarity: clarityMatch ? parseFloat(clarityMatch[1]) : 0
              };

              // Get author info from issue
              const issue = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });

              const body = issue.data.body || '';
              const authorsMatch = body.match(/\*\*Authors:\*\* (.+)/);

              // Send notification
              const response = await fetch('${{ env.PDF_WORKER_URL }}/notify/review-complete', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  submissionId,
                  title,
                  authorEmail: issue.data.user.email || '',
                  authorName: authorsMatch ? authorsMatch[1].split(',')[0].trim() : '',
                  decision: decision.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                  scores,
                  summary: rationaleMatch ? rationaleMatch[1].trim().replace(/^\s+/gm, '').slice(0, 500) : ''
                })
              });
              console.log('Review complete email sent:', response.ok);
            } catch (e) {
              console.log('Email notification failed (non-critical):', e.message);
            }

      - name: Commit reviews
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ðŸ“„ Add submission ${{ steps.metadata.outputs.submission_id }}"
          file_pattern: "submissions/** reviews/**"
