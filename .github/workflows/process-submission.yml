name: Process Submission

on:
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: write

env:
  PYTHON_VERSION: '3.11'

jobs:
  # Process submission when issue is created with PDF attached
  process-submission:
    name: Process Submission
    if: |
      (github.event_name == 'issues' && github.event.action == 'opened' && contains(github.event.issue.labels.*.name, 'submission')) ||
      (github.event_name == 'issue_comment' && contains(github.event.issue.labels.*.name, 'submission'))
    runs-on: ubuntu-latest
    steps:
      - name: Check for PDF attachment
        id: check-pdf
        uses: actions/github-script@v7
        with:
          script: |
            // Check both issue body and comment for PDF (comment may just be a trigger)
            const issueBody = context.payload.issue.body || '';
            const commentBody = context.eventName === 'issue_comment' ? (context.payload.comment.body || '') : '';

            console.log('Event type:', context.eventName);
            console.log('Checking issue body and comment for PDF...');

            // Look for PDF attachment - GitHub uses various formats
            const patterns = [
              /\[([^\]]*\.pdf)\]\((https:\/\/github\.com\/user-attachments\/[^)]+)\)/gi,
              /\[([^\]]*)\]\((https:\/\/github\.com\/user-attachments\/[^)]+\.pdf[^)]*)\)/gi,
              /(https:\/\/github\.com\/user-attachments\/files\/[a-f0-9\/\-\.]+)/gi,
              /(https:\/\/github\.com\/user-attachments\/assets\/[a-f0-9-]+)/gi
            ];

            function findPdfUrl(content) {
              for (const pattern of patterns) {
                pattern.lastIndex = 0;
                const match = content.match(pattern);
                if (match) {
                  const urlMatch = match[0].match(/(https:\/\/github\.com\/user-attachments\/[^\s\)]+)/);
                  if (urlMatch) return urlMatch[1];
                }
              }
              return null;
            }

            // Check comment first (in case user attached PDF in comment), then issue body
            let pdfUrl = findPdfUrl(commentBody) || findPdfUrl(issueBody);

            if (pdfUrl) {
              core.setOutput('has_pdf', 'true');
              core.setOutput('pdf_url', pdfUrl);
              console.log('Found PDF URL:', pdfUrl);
            } else {
              core.setOutput('has_pdf', 'false');
              console.log('No PDF found');

              // If this is a new issue without PDF, post instructions
              if (context.eventName === 'issues') {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: `## üìÑ Submission Received!\n\n‚ö†Ô∏è **No PDF detected in your submission.**\n\nPlease reply to this issue with your paper PDF attached (drag & drop the file into the comment box).\n\nOnce you attach the PDF, the automated review will begin.`
                });

                await github.rest.issues.addLabels({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  labels: ['waiting-for-pdf']
                });
              }
            }

      - name: Checkout
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: actions/checkout@v4

      - name: Setup Python
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        if: steps.check-pdf.outputs.has_pdf == 'true'
        run: pip install -r requirements.txt

      - name: Extract submission metadata
        if: steps.check-pdf.outputs.has_pdf == 'true'
        id: metadata
        uses: actions/github-script@v7
        with:
          script: |
            // Get the issue body
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const body = issue.data.body;

            // Extract submission ID
            const idMatch = body.match(/\*\*Submission ID:\*\* ([\w-]+)/);
            const submissionId = idMatch ? idMatch[1] : `AJ-${Date.now().toString(36).toUpperCase()}`;

            // Extract title
            const titleMatch = body.match(/\*\*Title:\*\* (.+)/);
            const title = titleMatch ? titleMatch[1].trim() : issue.data.title.replace('[Submission] ', '');

            core.setOutput('submission_id', submissionId);
            core.setOutput('title', title);
            console.log('Submission ID:', submissionId);
            console.log('Title:', title);

      - name: Download PDF
        if: steps.check-pdf.outputs.has_pdf == 'true'
        run: |
          mkdir -p submissions/${{ steps.metadata.outputs.submission_id }}
          curl -L "${{ steps.check-pdf.outputs.pdf_url }}" -o submissions/${{ steps.metadata.outputs.submission_id }}/paper.pdf
          echo "PDF downloaded successfully"
          ls -la submissions/${{ steps.metadata.outputs.submission_id }}/

      - name: Create metadata.yaml
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const body = issue.data.body;
            const submissionId = '${{ steps.metadata.outputs.submission_id }}';

            // Parse metadata from issue body
            const titleMatch = body.match(/\*\*Title:\*\* (.+)/);
            const typeMatch = body.match(/\*\*Type:\*\* (\w+)/);
            const authorsMatch = body.match(/\*\*Authors:\*\* (.+)/);
            const abstractMatch = body.match(/### Abstract\n([\s\S]*?)(?=\n###|$)/);
            const keywordsMatch = body.match(/### Keywords\n(.+)/);

            const metadata = {
              title: titleMatch ? titleMatch[1].trim() : 'Untitled',
              paper_type: typeMatch ? typeMatch[1].toLowerCase() : 'research',
              authors: [],
              abstract: abstractMatch ? abstractMatch[1].trim() : '',
              keywords: keywordsMatch ? keywordsMatch[1].split(',').map(k => k.trim()) : []
            };

            // Parse authors
            if (authorsMatch) {
              const authorNames = authorsMatch[1].split(',').map(a => a.trim());
              metadata.authors = authorNames.map(name => ({ name, email: '', affiliation: '' }));
            }

            // Write metadata file as YAML (simple manual serialization)
            const authorsYaml = metadata.authors.map(a => `  - name: "${a.name}"\n    email: ""\n    affiliation: ""`).join('\n');
            const keywordsYaml = metadata.keywords.map(k => `  - "${k}"`).join('\n');
            const yamlContent = `title: "${metadata.title.replace(/"/g, '\\"')}"\npaper_type: ${metadata.paper_type}\nauthors:\n${authorsYaml}\nabstract: |\n  ${metadata.abstract.replace(/\n/g, '\n  ')}\nkeywords:\n${keywordsYaml}\n`;
            fs.writeFileSync(`submissions/${submissionId}/metadata.yaml`, yamlContent);
            console.log('Metadata created:', yamlContent);

      - name: Update issue status
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const submissionId = '${{ steps.metadata.outputs.submission_id }}';

            // Remove waiting-for-pdf, add processing
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'waiting-for-pdf'
              });
            } catch (e) {}

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['processing']
            });

            // Post status update
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## üöÄ Processing Started!\n\n**Submission ID:** ${submissionId}\n\nYour PDF has been received and the review process is starting.\n\n| Stage | Status |\n|-------|--------|\n| PDF Received | ‚úÖ Complete |\n| Validation | üîÑ In Progress |\n| Agent Reviews | ‚è≥ Pending |\n| Meta-Review | ‚è≥ Pending |\n\nWe'll update this issue with results as each stage completes.`
            });

      - name: Run validation
        if: steps.check-pdf.outputs.has_pdf == 'true'
        id: validate
        continue-on-error: true
        run: |
          python scripts/validate_submission.py
        env:
          SUBMISSION_ID: ${{ steps.metadata.outputs.submission_id }}

      - name: Run reviews
        if: steps.check-pdf.outputs.has_pdf == 'true' && steps.validate.outcome == 'success'
        run: |
          for agent in technical domain ethics clarity; do
            echo "Running $agent review..."
            python scripts/run_review.py --agent $agent || true
          done
        env:
          SUBMISSION_ID: ${{ steps.metadata.outputs.submission_id }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

      - name: Run meta-review
        if: steps.check-pdf.outputs.has_pdf == 'true' && steps.validate.outcome == 'success'
        id: meta
        run: python scripts/synthesize_reviews.py
        env:
          SUBMISSION_ID: ${{ steps.metadata.outputs.submission_id }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}

      - name: Post review results
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const submissionId = '${{ steps.metadata.outputs.submission_id }}';

            let reviewComment = '';

            try {
              // Load meta-review (simple YAML parsing for key fields)
              const content = fs.readFileSync(`reviews/${submissionId}/meta-review.yaml`, 'utf8');

              // Extract key fields with regex
              const decisionMatch = content.match(/^decision:\s*(.+)$/m);
              const rationaleMatch = content.match(/^rationale:\s*[|>]?\s*\n([\s\S]*?)(?=^\w+:|$)/m);
              const weightedMatch = content.match(/weighted_average:\s*([\d.]+)/);
              const technicalMatch = content.match(/technical:\s*([\d.]+)/);
              const domainMatch = content.match(/domain:\s*([\d.]+)/);
              const ethicsMatch = content.match(/ethics:\s*([\d.]+)/);
              const clarityMatch = content.match(/clarity:\s*([\d.]+)/);

              const decision = decisionMatch ? decisionMatch[1].trim().toUpperCase() : 'PENDING';
              const rationale = rationaleMatch ? rationaleMatch[1].trim().replace(/^\s+/gm, '') : 'No rationale provided.';
              const weighted = weightedMatch ? parseFloat(weightedMatch[1]).toFixed(1) : 'N/A';
              const technical = technicalMatch ? parseFloat(technicalMatch[1]).toFixed(1) : 'N/A';
              const domain = domainMatch ? parseFloat(domainMatch[1]).toFixed(1) : 'N/A';
              const ethics = ethicsMatch ? parseFloat(ethicsMatch[1]).toFixed(1) : 'N/A';
              const clarity = clarityMatch ? parseFloat(clarityMatch[1]).toFixed(1) : 'N/A';

              const emoji = { 'ACCEPT': '‚úÖ', 'MINOR_REVISION': 'üìù', 'MAJOR_REVISION': 'üîÑ', 'REJECT': '‚ùå' }[decision] || '‚è≥';

              reviewComment = `## ${emoji} Review Complete: ${decision}\n\n**Submission ID:** ${submissionId}\n**Weighted Score:** ${weighted}/5.0\n\n### Score Breakdown\n\n| Agent | Score |\n|-------|-------|\n| Technical | ${technical} |\n| Domain | ${domain} |\n| Ethics | ${ethics} |\n| Clarity | ${clarity} |\n\n### Decision Rationale\n\n${rationale}\n\n---\n\n*Review generated by Agentic Journal's multi-agent peer review system.*\n\n[View on Dashboard](https://akz4ol.github.io/agentic-journal/dashboard/)`;

            } catch (error) {
              reviewComment = `## ‚ö†Ô∏è Review Processing Issue\n\nThere was an issue processing the review. Please check the workflow logs.\n\nError: ${error.message}`;
            }

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: reviewComment
            });

            // Update labels
            try {
              await github.rest.issues.removeLabel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                name: 'processing'
              });
            } catch (e) {}

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['completed']
            });

      - name: Commit reviews
        if: steps.check-pdf.outputs.has_pdf == 'true'
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "üìÑ Add submission ${{ steps.metadata.outputs.submission_id }}"
          file_pattern: "submissions/** reviews/**"
